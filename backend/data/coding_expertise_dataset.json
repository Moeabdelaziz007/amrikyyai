[
  {
    "id": "algo-001",
    "title": "Advanced Data Structures and Algorithms",
    "content": "## Advanced Data Structures\n\n### 1. Trie (Prefix Tree)\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n    \n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n```\n\n### 2. Segment Tree\n```python\nclass SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.build(arr, 0, 0, self.n - 1)\n    \n    def build(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build(arr, 2*node+1, start, mid)\n            self.build(arr, 2*node+2, mid+1, end)\n            self.tree[node] = self.tree[2*node+1] + self.tree[2*node+2]\n```",
    "category": "algorithms",
    "difficulty": "advanced",
    "language": "python",
    "tags": ["data-structures", "algorithms", "trees", "optimization"]
  },
  {
    "id": "design-001", 
    "title": "SOLID Principles in Practice",
    "content": "## SOLID Principles Implementation\n\n### 1. Single Responsibility Principle (SRP)\n```python\n# Bad: Class has multiple responsibilities\nclass UserManager:\n    def create_user(self, user_data):\n        # User creation logic\n        pass\n    \n    def send_email(self, user, message):\n        # Email sending logic\n        pass\n    \n    def log_activity(self, activity):\n        # Logging logic\n        pass\n\n# Good: Separate responsibilities\nclass UserService:\n    def __init__(self, email_service, logger):\n        self.email_service = email_service\n        self.logger = logger\n    \n    def create_user(self, user_data):\n        user = User(user_data)\n        self.logger.log(f'User created: {user.id}')\n        return user\n\nclass EmailService:\n    def send_email(self, user, message):\n        # Email sending logic\n        pass\n\nclass Logger:\n    def log(self, message):\n        # Logging logic\n        pass\n```\n\n### 2. Open/Closed Principle\n```python\nfrom abc import ABC, abstractmethod\n\nclass PaymentProcessor(ABC):\n    @abstractmethod\n    def process_payment(self, amount):\n        pass\n\nclass CreditCardProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        return f'Processing ${amount} via Credit Card'\n\nclass PayPalProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        return f'Processing ${amount} via PayPal'\n\nclass PaymentService:\n    def __init__(self, processor: PaymentProcessor):\n        self.processor = processor\n    \n    def handle_payment(self, amount):\n        return self.processor.process_payment(amount)\n```",
    "category": "design-patterns",
    "difficulty": "intermediate",
    "language": "python", 
    "tags": ["solid", "design-patterns", "clean-code", "architecture"]
  },
  {
    "id": "concurrency-001",
    "title": "Advanced Concurrency Patterns",
    "content": "## Concurrency and Async Programming\n\n### 1. Producer-Consumer Pattern with asyncio\n```python\nimport asyncio\nimport random\nfrom asyncio import Queue\n\nclass AsyncProducerConsumer:\n    def __init__(self, max_queue_size=10):\n        self.queue = Queue(maxsize=max_queue_size)\n        self.running = True\n    \n    async def producer(self, name, num_items):\n        for i in range(num_items):\n            if not self.running:\n                break\n            \n            item = f'{name}-item-{i}'\n            await self.queue.put(item)\n            print(f'Producer {name} produced: {item}')\n            await asyncio.sleep(random.uniform(0.1, 0.5))\n    \n    async def consumer(self, name):\n        while self.running or not self.queue.empty():\n            try:\n                item = await asyncio.wait_for(self.queue.get(), timeout=1.0)\n                print(f'Consumer {name} consumed: {item}')\n                self.queue.task_done()\n                await asyncio.sleep(random.uniform(0.2, 0.8))\n            except asyncio.TimeoutError:\n                if not self.running:\n                    break\n    \n    async def run(self):\n        producers = [\n            self.producer('P1', 5),\n            self.producer('P2', 5)\n        ]\n        consumers = [\n            self.consumer('C1'),\n            self.consumer('C2')\n        ]\n        \n        # Start all tasks\n        tasks = producers + consumers\n        await asyncio.gather(*tasks)\n```\n\n### 2. Thread Pool Executor for CPU-bound tasks\n```python\nimport concurrent.futures\nimport time\nimport threading\n\ndef cpu_bound_task(n):\n    \"\"\"Simulate CPU-intensive work\"\"\"\n    result = sum(i * i for i in range(n))\n    thread_id = threading.current_thread().ident\n    return f'Thread {thread_id}: {result}'\n\nclass OptimizedTaskProcessor:\n    def __init__(self, max_workers=None):\n        self.max_workers = max_workers or 4\n    \n    def process_tasks_parallel(self, tasks):\n        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            future_to_task = {executor.submit(cpu_bound_task, task): task for task in tasks}\n            results = []\n            \n            for future in concurrent.futures.as_completed(future_to_task):\n                task = future_to_task[future]\n                try:\n                    result = future.result()\n                    results.append(result)\n                except Exception as exc:\n                    print(f'Task {task} generated an exception: {exc}')\n            \n            return results\n```",
    "category": "concurrency",
    "difficulty": "advanced",
    "language": "python",
    "tags": ["asyncio", "threading", "concurrency", "performance"]
  },
  {
    "id": "testing-001",
    "title": "Advanced Testing Strategies",
    "content": "## Comprehensive Testing Approaches\n\n### 1. Test-Driven Development (TDD)\n```python\nimport pytest\nfrom unittest.mock import Mock, patch\n\n# First, write the test\nclass TestUserService:\n    def test_create_user_success(self):\n        # Arrange\n        user_repo = Mock()\n        email_service = Mock()\n        user_service = UserService(user_repo, email_service)\n        user_data = {'name': 'John', 'email': 'john@example.com'}\n        \n        # Act\n        result = user_service.create_user(user_data)\n        \n        # Assert\n        assert result.name == 'John'\n        user_repo.save.assert_called_once()\n        email_service.send_welcome_email.assert_called_once()\n    \n    def test_create_user_invalid_email(self):\n        user_repo = Mock()\n        email_service = Mock()\n        user_service = UserService(user_repo, email_service)\n        user_data = {'name': 'John', 'email': 'invalid-email'}\n        \n        with pytest.raises(InvalidEmailError):\n            user_service.create_user(user_data)\n    \n    @patch('requests.post')\n    def test_api_integration(self, mock_post):\n        # Mock external API response\n        mock_post.return_value.json.return_value = {'status': 'success'}\n        mock_post.return_value.status_code = 200\n        \n        api_client = APIClient()\n        result = api_client.send_data({'key': 'value'})\n        \n        assert result['status'] == 'success'\n        mock_post.assert_called_once()\n\n# Then implement the actual code\nclass UserService:\n    def __init__(self, user_repo, email_service):\n        self.user_repo = user_repo\n        self.email_service = email_service\n    \n    def create_user(self, user_data):\n        if not self._is_valid_email(user_data['email']):\n            raise InvalidEmailError('Invalid email format')\n        \n        user = User(user_data)\n        self.user_repo.save(user)\n        self.email_service.send_welcome_email(user)\n        return user\n    \n    def _is_valid_email(self, email):\n        import re\n        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n        return re.match(pattern, email) is not None\n```\n\n### 2. Property-Based Testing\n```python\nfrom hypothesis import given, strategies as st\nimport pytest\n\nclass MathUtils:\n    @staticmethod\n    def fibonacci(n):\n        if n <= 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return MathUtils.fibonacci(n-1) + MathUtils.fibonacci(n-2)\n    \n    @staticmethod\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\nclass TestMathUtils:\n    @given(st.integers(min_value=0, max_value=10))\n    def test_fibonacci_properties(self, n):\n        result = MathUtils.fibonacci(n)\n        assert result >= 0\n        \n        if n >= 2:\n            # Fibonacci property: F(n) = F(n-1) + F(n-2)\n            assert result == MathUtils.fibonacci(n-1) + MathUtils.fibonacci(n-2)\n    \n    @given(st.integers(min_value=2, max_value=100))\n    def test_prime_properties(self, n):\n        is_prime = MathUtils.is_prime(n)\n        \n        if is_prime:\n            # If n is prime, it should have exactly 2 divisors: 1 and n\n            divisors = [i for i in range(1, n+1) if n % i == 0]\n            assert len(divisors) == 2\n            assert divisors == [1, n]\n```",
    "category": "testing",
    "difficulty": "advanced", 
    "language": "python",
    "tags": ["tdd", "unit-testing", "mocking", "property-testing", "pytest"]
  },
  {
    "id": "architecture-001",
    "title": "Clean Architecture and Domain-Driven Design",
    "content": "## Clean Architecture Implementation\n\n### 1. Hexagonal Architecture (Ports and Adapters)\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n# Domain Entities\n@dataclass\nclass User:\n    id: Optional[int]\n    email: str\n    name: str\n    created_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.utcnow()\n\n# Domain Repository Interface (Port)\nclass UserRepositoryInterface(ABC):\n    @abstractmethod\n    def save(self, user: User) -> User:\n        pass\n    \n    @abstractmethod\n    def find_by_email(self, email: str) -> Optional[User]:\n        pass\n    \n    @abstractmethod\n    def find_all(self) -> List[User]:\n        pass\n\n# Domain Service\nclass UserDomainService:\n    def __init__(self, user_repo: UserRepositoryInterface):\n        self.user_repo = user_repo\n    \n    def create_user(self, email: str, name: str) -> User:\n        existing_user = self.user_repo.find_by_email(email)\n        if existing_user:\n            raise ValueError(f'User with email {email} already exists')\n        \n        user = User(id=None, email=email, name=name)\n        return self.user_repo.save(user)\n\n# Infrastructure - Database Adapter\nclass SQLUserRepository(UserRepositoryInterface):\n    def __init__(self, db_connection):\n        self.db = db_connection\n    \n    def save(self, user: User) -> User:\n        if user.id is None:\n            # Insert new user\n            cursor = self.db.execute(\n                'INSERT INTO users (email, name, created_at) VALUES (?, ?, ?)',\n                (user.email, user.name, user.created_at)\n            )\n            user.id = cursor.lastrowid\n        else:\n            # Update existing user\n            self.db.execute(\n                'UPDATE users SET email=?, name=? WHERE id=?',\n                (user.email, user.name, user.id)\n            )\n        return user\n    \n    def find_by_email(self, email: str) -> Optional[User]:\n        cursor = self.db.execute(\n            'SELECT id, email, name, created_at FROM users WHERE email = ?',\n            (email,)\n        )\n        row = cursor.fetchone()\n        if row:\n            return User(id=row[0], email=row[1], name=row[2], created_at=row[3])\n        return None\n    \n    def find_all(self) -> List[User]:\n        cursor = self.db.execute('SELECT id, email, name, created_at FROM users')\n        return [User(id=row[0], email=row[1], name=row[2], created_at=row[3]) \n                for row in cursor.fetchall()]\n\n# Application Service (Use Case)\nclass UserApplicationService:\n    def __init__(self, user_domain_service: UserDomainService):\n        self.user_domain_service = user_domain_service\n    \n    def register_user(self, email: str, name: str) -> dict:\n        try:\n            user = self.user_domain_service.create_user(email, name)\n            return {\n                'success': True,\n                'user_id': user.id,\n                'message': 'User registered successfully'\n            }\n        except ValueError as e:\n            return {\n                'success': False,\n                'error': str(e)\n            }\n\n# Web Controller (Adapter)\nclass UserController:\n    def __init__(self, user_app_service: UserApplicationService):\n        self.user_app_service = user_app_service\n    \n    def register_endpoint(self, request_data: dict) -> dict:\n        email = request_data.get('email')\n        name = request_data.get('name')\n        \n        if not email or not name:\n            return {'error': 'Email and name are required', 'status': 400}\n        \n        result = self.user_app_service.register_user(email, name)\n        status = 201 if result['success'] else 400\n        \n        return {**result, 'status': status}\n```\n\n### 2. Command Query Responsibility Segregation (CQRS)\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Dict\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n# Commands (Write Operations)\n@dataclass\nclass CreateUserCommand:\n    email: str\n    name: str\n    timestamp: datetime = None\n    \n    def __post_init__(self):\n        if not self.timestamp:\n            self.timestamp = datetime.utcnow()\n\n@dataclass\nclass UpdateUserCommand:\n    user_id: int\n    email: str\n    name: str\n    timestamp: datetime = None\n    \n    def __post_init__(self):\n        if not self.timestamp:\n            self.timestamp = datetime.utcnow()\n\n# Command Handlers\nclass CommandHandler(ABC):\n    @abstractmethod\n    def handle(self, command: Any) -> Any:\n        pass\n\nclass CreateUserCommandHandler(CommandHandler):\n    def __init__(self, user_repo: UserRepositoryInterface):\n        self.user_repo = user_repo\n    \n    def handle(self, command: CreateUserCommand) -> User:\n        user = User(id=None, email=command.email, name=command.name)\n        return self.user_repo.save(user)\n\n# Queries (Read Operations)\n@dataclass\nclass GetUserByEmailQuery:\n    email: str\n\n@dataclass\nclass GetAllUsersQuery:\n    limit: int = 100\n    offset: int = 0\n\n# Query Handlers\nclass QueryHandler(ABC):\n    @abstractmethod\n    def handle(self, query: Any) -> Any:\n        pass\n\nclass GetUserByEmailQueryHandler(QueryHandler):\n    def __init__(self, user_repo: UserRepositoryInterface):\n        self.user_repo = user_repo\n    \n    def handle(self, query: GetUserByEmailQuery) -> Optional[User]:\n        return self.user_repo.find_by_email(query.email)\n\n# Command/Query Bus\nclass MessageBus:\n    def __init__(self):\n        self.command_handlers: Dict[type, CommandHandler] = {}\n        self.query_handlers: Dict[type, QueryHandler] = {}\n    \n    def register_command_handler(self, command_type: type, handler: CommandHandler):\n        self.command_handlers[command_type] = handler\n    \n    def register_query_handler(self, query_type: type, handler: QueryHandler):\n        self.query_handlers[query_type] = handler\n    \n    def execute_command(self, command: Any) -> Any:\n        handler = self.command_handlers.get(type(command))\n        if not handler:\n            raise ValueError(f'No handler registered for {type(command)}')\n        return handler.handle(command)\n    \n    def execute_query(self, query: Any) -> Any:\n        handler = self.query_handlers.get(type(query))\n        if not handler:\n            raise ValueError(f'No handler registered for {type(query)}')\n        return handler.handle(query)\n```",
    "category": "architecture",
    "difficulty": "expert",
    "language": "python",
    "tags": ["clean-architecture", "hexagonal-architecture", "cqrs", "ddd", "design-patterns"]
  }
]
